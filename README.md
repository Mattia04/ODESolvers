# ODE Solvers

This repo contains the comparison between methods of solving ODE integrations.

The initial idea was to compare those methods in the repo:
[A lot of Pendulums](https://github.com/Mattia04/a-Lot-of-Pendulums), but I 
later decided to separate this comparison from that project because this 
comparison is a project itself.

NOTE: THIS FILE HAS BEEN GENERATED BY AN AI TO MAKE ME REMEBER WHAT I WANT 
TO DO. (I know the implementations below are shit).

## ODE Integrator Methods List

### Fixed-Step RK Methods (Orders 3–8)

- Midpoint Method (Second-Order RK)
-    RK3 (Kutta's Third-Order)
-    RK4 (Classic Fourth-Order)
- RK3/8 Rule (Fourth-Order RK variant)
-    RK5 (Nyström's Fifth-Order)
-    RK6 (Butcher's Sixth-Order)
-    RK8 (Cooper-Verner Eighth-Order)
- Gauss-Legendre Methods (Implicit RK)
Coefficients: Use Butcher Tableaus. Source: Butcher Tableau Database or Hairer's Solving Ordinary Differential Equations I.

### Variable-Step Methods

-    Dormand-Prince 5(4) (MATLAB's `ode45`)
-    Fehlberg 4(5)
-    Cash-Karp 5(4)
-    Bogacki-Shampine 3(2)
-    Tsitouras 5(4)
- Verner 6(5)
- Dormand-Prince 8(7)
- Radau IIA (Implicit RK)
Coefficients: Embedded methods with adaptive step control. See Dormand & Prince (1980) or `boost::numeric::odeint` implementations.

### Symplectic Methods

- Symplectic Euler 
- Implicit Midpoint Method
-    Verlet (Position Verlet)
-    Velocity Verlet
-    Leapfrog
-    Forest-Ruth 4th Order
-    Yoshida 6th Order
Coefficients: Derived from Hamiltonian splitting. Source: Hairer's Geometric Numerical Integration.

## Code Architecture

### Base classes

#### `MyFunctor`

For implementing physical systems

```c++
class MyFunctor {
public:
    virtual void operator()(const std::vector<double>& state, 
                            std::vector<double>& derivative, 
                            double t) = 0;
    virtual double energy(const std::vector<double>& state, double t) = 0;
};
```

##### Physical systems

 -   Harmonic Oscillator 
 -   Double Pendulum (Chaotic, non-Hamiltonian)
 -   Kepler Problem (Orbital mechanics, tests energy conservation)
 -   Rigid Body Rotation (Euler equations)
 -   Lotka-Volterra (Predator-prey model)
 - Hénon-Heiles System
 - Magnetic Pendulum
 - Van der Pol Oscillator
 - Lorenz System
 - Elastic Pendulum

#### `ODESolver`

For the solvers

```c++
class ODESolver {
public:
    virtual void solve(const MyFunctor& system, 
                       std::vector<double>& state, 
                       double t_start, double t_end, 
                       double& step_size, 
                       std::ostream& output) = 0;
};
```

##### Solvers

###### Fixed-Step RK Template

```cpp
template <typename ButcherTableau>
class FixedRKSolver : public ODESolver {
    // Use Butcher tableau coefficients (a, b, c)
    // Implement step() method with k1, k2, ..., kn stages
};
```

###### Adaptive Step Controller

```cpp
class AdaptiveSolver : public ODESolver {
    // Use error estimation (e.g., |y_high - y_low|)
    // Adjust step size via PID control
};
```

###### Symplectic Solver

```cpp
class VerletSolver : public ODESolver {
    // Split Hamiltonian into T(p) + V(q)
    // Implement position/velocity half-steps
};
```

## Data Collection

For each integrator/system pair, log:
`t, state, energy, step_size, wall_clock_time, local_error, global_error`

Error Calculation: Compare to analytical solution (if available) or a high-precision reference solver.

Output Format: CSV files per method/system/step, e.g., 
`rk4_double_pendulum_0.1.csv`.

## Python Analysis Scripts

Use pandas and matplotlib to generate:

-    Global Error vs. Step Size (log-log plot for fixed-step methods).
-    Energy Drift (Energy(t) - E0 for symplectic vs non-symplectic).
-    Efficiency (Accuracy vs. Wall-clock time).
-    [not necessary] Phase-Space Plots (q vs p for Hamiltonian systems).
- Lyapunov Exponents, For chaotic systems.
